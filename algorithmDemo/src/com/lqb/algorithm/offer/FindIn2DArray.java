package com.lqb.algorithm.offer;

public class FindIn2DArray {

	public static void main(String[] args) {
		 int[][] array = {{1,2,4,6,8,10,11,13,15,17,20,22,24,27,30,32,35,36,38,39,42,44,46,47,48,49,51,54,55,56},{3,4,6,8,11,13,15,18,19,20,23,25,27,29,33,36,38,41,42,45,48,50,53,54,57,60,63,65,66,67},{5,7,8,11,14,15,17,19,21,23,24,28,31,33,36,39,41,44,47,49,52,53,56,57,60,63,66,68,71,72},{7,10,13,14,17,19,22,25,26,27,30,32,34,37,39,42,44,46,50,53,55,56,59,61,64,66,69,72,74,76},{8,12,16,17,20,21,23,26,29,31,33,35,37,40,42,45,48,49,52,55,58,59,61,63,67,69,70,74,76,79},{10,15,18,20,22,24,27,30,32,33,36,38,39,41,45,47,50,53,56,58,61,64,65,68,69,71,73,76,79,82},{13,17,20,23,24,26,28,31,34,36,38,41,42,43,48,50,53,56,58,61,64,67,68,71,73,74,75,78,81,84},{15,19,22,24,26,28,31,34,35,38,41,44,45,46,49,51,56,59,61,64,67,69,71,73,76,78,79,82,85,87},{17,20,23,26,29,30,32,37,40,42,43,47,50,53,55,56,58,62,64,66,69,72,75,78,80,81,83,86,88,90},{18,21,25,28,30,32,35,38,42,43,44,49,51,55,58,59,61,65,68,71,73,74,77,79,82,85,88,89,91,93},{20,23,28,29,33,36,37,40,43,45,47,52,55,58,60,62,63,66,70,74,76,77,79,81,85,88,89,91,93,94},{23,25,31,33,35,39,42,43,44,46,50,53,56,61,62,65,68,69,72,75,78,81,82,83,88,91,92,93,96,99},{26,27,33,34,38,40,45,48,51,53,55,56,58,64,66,69,72,75,77,80,82,84,87,88,90,93,94,95,99,101},{29,30,36,38,40,42,47,50,53,56,57,59,62,65,68,71,73,77,79,83,84,86,88,91,93,96,99,100,102,103},{32,33,39,42,44,46,49,53,56,59,62,65,68,71,72,75,77,78,80,85,87,90,92,94,96,99,101,103,105,107},{35,37,42,43,46,48,51,55,59,61,65,67,71,74,76,78,81,82,84,86,90,92,95,96,99,102,103,106,107,109},{36,39,43,46,49,50,53,58,62,65,67,70,73,76,77,79,84,87,88,90,93,96,99,102,103,106,108,111,112,115},{38,42,45,47,52,55,57,60,64,66,69,72,75,78,80,82,87,89,91,92,94,99,100,103,105,107,111,112,115,118},{39,44,48,49,55,57,60,63,66,69,72,75,78,80,82,85,89,92,94,95,98,101,102,105,108,111,112,115,116,120},{40,47,49,52,56,59,63,64,68,71,75,78,80,83,85,88,91,94,97,99,101,104,105,108,110,112,115,118,120,123},{42,50,53,55,59,62,66,67,71,73,78,81,82,86,87,90,94,97,100,101,104,106,107,109,111,114,117,120,123,126},{43,51,55,58,62,64,69,71,74,77,81,84,86,87,89,93,96,99,102,103,105,108,111,112,113,116,120,122,125,129},{45,54,56,59,65,67,72,75,76,79,84,87,90,92,94,97,99,102,104,107,108,111,114,116,119,120,122,124,127,132},{47,55,59,62,66,68,74,78,80,82,85,88,93,96,99,101,102,105,106,108,110,113,115,118,120,121,124,127,130,133},{49,56,61,65,68,70,76,81,83,85,87,91,95,99,102,103,104,106,108,110,113,116,118,121,124,127,130,133,134,137},{51,57,62,68,71,74,78,83,86,89,92,95,97,101,104,106,108,110,113,114,117,119,121,123,126,130,132,135,137,140},{53,59,65,69,73,75,81,86,88,92,95,97,100,103,107,109,111,112,115,117,120,122,125,126,129,131,133,138,141,143},{55,61,67,72,75,77,82,89,92,94,97,100,102,105,108,111,114,115,116,119,123,125,126,128,131,134,137,140,144,146},{57,63,68,74,78,81,85,90,95,98,100,101,103,107,110,114,117,119,120,123,126,129,130,133,136,138,141,144,146,149},{58,65,70,76,81,84,86,93,98,101,104,105,107,110,112,115,120,122,124,126,129,132,135,136,138,140,142,146,149,150}};
		
		 System.out.println(find3(array,102));

	}

	/**
	 * @Description: 最佳解法，从尾部最后一个值往下开始遍历，如果比最后一个值大则往下，如果小则当前行下往回遍历，遇到比target值小的再往下遍历，以此类推直到找到对的
	 * @author:JackBauer
	 * @Date:2016年5月26日下午8:59:34
	 */
	public static boolean find3(int[][] array, int target) {
		boolean found = false;
        int lie = array[0].length;
        int hang = array.length;   
        int column = lie -1;
        int row =0;
        
        while(row<hang &&column>=0){
           int value = array[row][column];
            if(target>value){
                row++;
            }else if(value>target){
                column--;
            }else{
                found = true;
                break;
            }
                  
        }
        return found;
	}
	
	/**
	 * @Description: 自己写的认为比n^2要小的算法，然而在oj上测试时比n^2消耗的内存和时间要多 - - 
	 * @author:JackBauer
	 * @Date:2016年5月26日下午8:58:39
	 */
	public static boolean find2(int[][] array, int target) {
		int i = 1;
		int start = 0;
		int end = array[0].length - 1;

		int mid = 0;
		//先用而二分查找找到中间的位置
		while (start <= end) {
			mid = (start + end) / 2;
			if (array[0][mid] > target) {
				end = mid - 1;
			} else if (array[0][mid] < target) {
				start = mid + 1;
			} else {
				System.out.println("array[0]["+mid+"]");
				return true;
			}
		}

		//从中间开始往下遍历，遇到比target大的则在当前行再次利用二分搜索
		while( i < array.length && mid >=0 ){
			if( array[i][mid] == target ){
				System.out.println("array["+i+"]["+mid+"]");
				return true;
			}else if( array[i][mid] > target ){
				start = 0;
				end = mid - 1;
				while (start <= end) {
					mid = (start + end) / 2;
					if (array[i][mid] > target) {
						end = mid - 1;
					} else if (array[i][mid] < target) {
						start = mid + 1;
					} else {
						System.out.println("array[0]["+mid+"]");
						return true;
					}
				}
			}
			i++;
		}
		return false;
	}

	/**
	 * @Description: 复杂度为n^2的解法
	 * @author:JackBauer
	 * @Date:2016年5月26日下午8:58:00
	 */
	public static boolean find1(int[][] array, int target) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array[i].length; j++) {
				if (array[i][j] == target) {
					return true;
				}
			}
		}

		return false;
	}

	/**
	 * @Description: 二分搜索
	 * @author:JackBauer
	 * @Date:2016年5月26日下午8:53:33
	 */
	public static boolean binarySearch(int[] arr, int n) {
		int start = 0;
		int end = arr.length - 1;
		int count = 0;
		boolean flag = false;

		while (start <= end) {
			int mid = (start + end) / 2;
			count++;
			if (arr[mid] > n) {
				end = mid - 1;
			} else if (arr[mid] < n) {
				start = mid + 1;
			} else {
				flag = true;
				break;
			}
		}

		System.out.println("count:" + count);
		return flag;
	}
}
